select id, name, cct from get_coa_list(3::smallint);
select id, name, cct from get_coa_list(6::smallint);
select id, name, cct from get_coa_list(6::smallint);
select id, name, code, cct from get_coa_list(6::smallint);
select id, name, code, cct from get_coa_list(4::smallint);
create function get_coa_parent()
returns table (
id int,
code varchar(4),
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select p.id, p.code::varchar(4) as code, p.name
  from coa as p
  order by p.name;
  

end;
$$
;
select id, name, cct from get_coa_parent();
select id, name, code from get_coa_parent();
drop function get_coa_list;
create function get_coa_parent()
returns table (
id int,
code varchar(4),
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select p.id, p.code::varchar(4) as code, p.name
  from coa as p
  where length(code) < 4
  order by p.name;
  

end;
$$
;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;drop function get_coa_list();
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4);
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4);
select id, name, code from get_coa_list(4::smallint);
\df
\df get_coa_list 
\dF get_coa_list 
\dft get_coa_list 
\df get_coa_list 
select id, name, code from get_coa_list(4::smallint);
return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < 4;
select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p;
select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as c;
 select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id;
select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c;
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4);
select id, name, code from get_coa_list(4::smallint);
return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < 4;
recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < 4;
drop function get_coa_list;
\df
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI') as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.link
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name varchar(50), 
tax_id int, 
description varchar(256), 
coa_type_id smallint, 
link varchar(50)[], 
parent_id int, 
updated_at varchar(20),
cct varchar(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::text, 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::text, 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
coa_type_id smallint, 
link character varying(50)[], 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
coa_type_id smallint, 
link character varying(50)[], 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
code varchar(4),
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code::varchar(4) as code,
    p.name
  from coa as p
  where length(p.code) < 4
  order by p.name;
  

end;
$$
;
select id, name, cct from get_coa_parent();
select id, name, code from get_coa_parent();
select
    p.id, 
    p.code::varchar(4) as code,
    p.name
  from coa as p
  where length(p.code) < 4
  order by p.name;
select
    p.id, 
    p.code::varchar(4) as code,
    p.name
  from coa as p
  where length(code) < 4
  order by p.name;
select
    p.id, 
    p.code::varchar(4) as code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
code varchar(4),
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code::varchar(4) as code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
  

end;
$$
;
select id, name, code from get_coa_parent();
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
parent_code varchar(4),
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code::varchar(4) as parent_code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
  

end;
$$
;
select id, parent_code, name from get_coa_parent();
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
code int,
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
  

end;
$$
;
select id, parent_code, name from get_coa_parent();
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
code int,
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
  

end;
$$
;
select id, code, name from get_coa_parent();
select
      id,
      code,
      name
    from get_coa_parent();
select
      id,
      code,
      name,
      tax_id,
      description,
      coa_type_id,
      link,
      parent_id,
      updated_at
    from get_coa_list(5::smallint);
select
      id,
      code,
      name,
      tax_id,
      description,
      coa_type_id,
      link,
      parent_id,
      updated_at
    from get_coa_list(6::smallint)
;
select
      id,
      code,
      name,
      tax_id,
      description,
      coa_type_id,
      link,
      parent_id,
      updated_at
    from get_coa_list(6::smallint);
select
      id,
      code,
      name
    from get_coa_parent();
select
      id,
      code,
      name
    from get_coa_parent();
select
      id,
      code,
      name
    from 'get_coa_parent()';
select
      id,
      code,
      name
    from call get_coa_parent();
select
      id,
      code,
      name
    from call get_coa_parent;
select
      id,
      code,
      name
    from get_coa_parent;
select
      id,
      code,
      name
    from get_coa_parent() as t;
select
      id,
      code,
      name
    from get_coa_parent() as t;
\df
SELECT s.id, s.code, s.name, s.description,
    s.tax_id AS "taxId", s.coa_type_id AS "coaTypeId", s.parent_id as "parentId"
    FROM coa AS s
;
SELECT p.parent_id, p.id, p.code, p.name,
    p.coa_type_id, p.tax_id, p.description from coa;
\d coa
SELECT p.parent_id, p.id, p.code, p.name,
    p.coa_type_id, p.tax_id, p.description from coa as p;
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 SELECT 
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      link
    FROM coa AS p
    WHERE POSITION(${p_name} IN LOWER(p.name)) > 0

 
end;
$$
;
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 SELECT 
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      link
    FROM coa AS p
    WHERE POSITION(p_name) IN LOWER(p.name)) > 0

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 SELECT 
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      link
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0

 
end;
$$
;
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 SELECT 
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      link
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 SELECT 
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      p.link
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      p.link
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
coa_type_id smallint, 
link character varying(50)[], 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 order by t.cct
 where length(t.code::varchar(4)) < p_length;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
coa_type_id smallint, 
link character varying(50)[], 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
\q
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
coa_type_id smallint, 
link character varying(50)[], 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.coa_type_id,
    p.link, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.coa_type_id,
    c.link, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.coa_type_id,
    t.link,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_parent;
create function get_coa_parent()
returns table (
id int,
code int,
name varchar(50)
)
language plpgsql
as $$

begin

 return query 
  select
    p.id, 
    p.code,
    p.name
  from coa as p
  where length(p.code::varchar(4)) < 4
  order by p.name;
  

end;
$$
;
select id, code, name from get_coa_parent();
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
coa_type_id smallint, 
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.coa_type_id,
      p.link
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
\q
\d product
select id, name from product where spbu_id = true;
select id, name from product where spbu_id = 1;
select id, name, be_sold from product where spbu_id = 1;
select id, name, be_sold from product where spbu_id = t;
select id, name, be_sold from product where spbu_id = 0;
select id, name, be_sold from product where spbu_id = 1;
select id, name, be_sold from product where spbu_id = 't';
select id, name, be_sold from product where be_sold = t;
select id, name, be_sold from product where be_sold = true;
update product set be_sold = false where id = ;
update product set be_sold = false where id = 0;
\q
update product set be_sold = false where id = 0
exit
\q
create CREATE SEQUENCE public.seq_order
    AS int
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.seq_order
    AS int
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
\d product 
CREATE SEQUENCE public.seq_order
    AS int
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
    
CREATE TABLE public.orders (
    journal_id integer DEFAULT 0 NOT NULL,
    id integer DEFAULT nextval('public.seq_order'::regclass) NOT NULL,
    product_id int not null default 0,
    type_id smallint not null default 0,
    qty decimal(10,2) not null default 0,
    real_qty decimal(10,2) not null default 0,
    content int not null default 0,
    debt decimal(10,2) not null default 0,
    cred decimal(10,2) not null default 0,
    unit varchar(6) not null,
    buy_price decimal(14,2) not null default 0,
    sale_price decimal(14,2) not null default 0,
    sub_total decimal(14,2) not null default 0,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT pk_orders PRIMARY KEY (id);
CREATE INDEX uq_orders_journal ON public.product USING btree (journal_id);
CREATE INDEX uq_orders_product ON public.product USING btree (product_id);
CREATE INDEX uq_orders_type ON public.product USING btree (type_id);
CREATE INDEX uq_orders_created ON public.product USING btree (created_at);
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT fk_journal_order FOREIGN KEY (journal_id) REFERENCES public.journal(id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT fk_journal_product FOREIGN KEY (product_id) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE RESTRICT; 
\d orders;
CREATE INDEX uq_orders_journal ON public.product USING btree (journal_id);
CREATE INDEX uq_orders_product ON public.product USING btree (product_id);
CREATE INDEX uq_orders_type ON public.product USING btree (type_id);
CREATE INDEX uq_orders_journal ON public.orders USING btree (journal_id);
CREATE INDEX uq_orders_product ON public.orders USING btree (product_id);
CREATE INDEX uq_orders_type ON public.orders USING btree (type_id);
CREATE INDEX uq_orders_created ON public.orders USING btree (created_at);
\d product
\d product
drop index uq_orders_created;
\d orders;
CREATE INDEX uq_orders_created ON public.orders USING btree (created_at);
\d orders;
drop constraint fk_journal_product;
alter table orders drop constraint fk_journal_product;
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT fk_roduct_orders FOREIGN KEY (product_id) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE RESTRICT;    
alter table orders drop column real_qty ;
select * from orders;
\q
CREATE SEQUENCE public.seq_order
    AS int
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
    
CREATE TABLE public.orders (
    journal_id integer DEFAULT 0 NOT NULL,
    id integer DEFAULT nextval('public.seq_order'::regclass) NOT NULL,
    product_id int not null default 0,
    type_id smallint not null default 0,
    qty decimal(10,2) not null default 0,
    content int not null default 0,
    debt decimal(10,2) not null default 0,
    cred decimal(10,2) not null default 0,
    unit varchar(6) not null,
    buy_price decimal(14,2) not null default 0,
    sale_price decimal(14,2) not null default 0,
    sub_total decimal(14,2) not null default 0,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT pk_orders PRIMARY KEY (id);
    
CREATE INDEX uq_orders_journal ON public.orders USING btree (journal_id);
CREATE INDEX uq_orders_product ON public.orders USING btree (product_id);
CREATE INDEX uq_orders_type ON public.orders USING btree (type_id);
CREATE INDEX uq_orders_created ON public.orders USING btree (created_at);
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT fk_journal_order FOREIGN KEY (journal_id) REFERENCES public.journal(id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE ONLY public.orders
    ADD CONSTRAINT fk_roduct_orders FOREIGN KEY (product_id) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE RESTRICT;    
\d orders
\q
select * from orders;
update product set be_sold = false where id = 0;
\q
alter table product add column first_stock decimal (10,2) not null default 0;
\q
alter table product add column first_stock decimal (10,2) not null default 0;
\q
SELECT e.debt, e.cred
    FROM orders AS e
    WHERE e.id = t.id
    ORDER BY id DESC
    LIMIT 1
;
sELECT e.debt, e.cred
    FROM orders AS e
    
    ORDER BY t.id DESC
    LIMIT 1
;
sELECT e.debt, e.cred
    FROM orders AS e
    
    ORDER BY r.id DESC
    LIMIT 1
;
sELECT e.debt, e.cred
    FROM orders AS e
    
    ORDER BY e.id DESC
    LIMIT 1
;
\d journal
\d customer
\d journal
select * from users;
\d journal
\d users;
alter table users alter column id type int;
drop SEQUENCE public.seq_user;
drop SEQUENCE public.seq_user CASCADE;
SELECT * FROM USERS;
CREATE SEQUENCE public.seq_user
    AS int
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
\d users;
alter table user alter column id set DEFAULT nextval('public.seq_user'::regclass);
alter table users alter column id set DEFAULT nextval('public.seq_user'::regclass);
\d users;
\d journal;
alter table journal add column user_id int not null;
alter table journal add column user_id int not null default 0;
update journal set user_id = 1;
create index ix_journal_user on journal using btree (user_id);
ALTER TABLE ONLY public.journal ADD CONSTRAINT fk_journal_user FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE RESTRICT;
\d journal;
\d journal_detail 
\d users;
\d
alter table journal add column customer_id int not null default 0;
select id, name from users;
insert into users select from users where id = 1;
select * from user;
select * from users;
insert into users values (select from users where id = 1);
insert into users values select from users where id = 1;
insert into users select from users where id = 1;
\d users;
select * from users;
insert into users (id , name , email , password , role , spbu_id , street , city , phone) values (
0 , Umum, 'doni@gmail.com', '-' , 'none', 1 , '-', '-' ,'-')
;
insert into users (id , name , email , password , role , spbu_id , street , city , phone) values (
0 , 'Umum', 'doni@gmail.com', '-' , 'none', 1 , '-', '-' ,'-');
insert into users (id , name , email , password , role , spbu_id , street , city , phone) values (
0 , 'Umum', '-', '-' , 'none', 1 , '-', '-' ,'-');
select * from users;
\d journal;
ALTER TABLE ONLY public.journal
    ADD CONSTRAINT fk_journal_customer FOREIGN KEY (customer_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE RESTRICT;
\d journal;
CREATE INDEX uq_journal_customer ON public.journal USING btree (customer_id);
\d journal;
select name, role from users;
update product set first_stock = 1000 where id = 121;
select * from product;
select id, name from product;
update product set first_stock = 1000 where id = 2;
update product set first_stock = 5000 where id = 10;
select id, name, cred, debt from product;
select id, name, first_stock from product;
select id,  from orders;
select id, debt, cred  from orders;
\q
alter table product add column first_stock decimal(10,2) not null default 0;
\d product 
\q
\l postgres
drop database mvkjhpga
;
\q
\q
\d
\q
\d orders;
select id, parent_id, name from coa;
delete from coa where id = 24;
select * from orders;
delete from orders;
select * from orders;
select * from orders;
select * from orders;
select id, product_id, cred, deb from orders;
select id, product_id, cred, debt from orders;
select id, product_id, p.name, cred, debt from orders join product as p where p.id = product_id;
select id, product_id, p.name, cred, debt from orders join product as p on p.id = product_id;
select o.id, o.product_id, p.name, o.cred, o.debt from orders o join product as p on p.id = o.product_id;
select o.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
select p.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
select * from orders;
select * from orders;
select o.journal_id, p.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
delete from orders;
select o.journal_id, p.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
delete from orders;
select o.journal_id, p.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
\d orders
select o.journal_id, p.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
select o.journal_id, o.id, o.product_id, p.name, o.debt, o.cred from orders o join product as p on p.id = o.product_id;
select o.journal_id, o.id, o.product_id, p.name, o.debt, o.cred, o.qty from orders o join product as p on p.id = o.product_id;
\d orders 
select o.journal_id, o.id, o.product_id, p.name, o.debt, o.cred, o.type_id from orders o join product as p on p.id = o.product_id;
alter table orders add column meter_debt decimal(14,2) not null default 0;
alter table orders add column meter_cred decimal(14,2) not null default 0;
\d orders;
delete from orders;
select o.journal_id, o.id, o.product_id, p.name, o.debt, o.cred, o.type_id from orders o join product as p on p.id = o.product_id;
select o.journal_id, o.id, o.product_id, p.name, o.debt, o.cred, o.qty from orders o join product as p on p.id = o.product_id;
select o.journal_id, o.id, o.product_id, p.name, o.meter_debt, o.meter_cred, o.qty from orders o join product as p on p.id = o.product_id;
\d product 
\d orders
alter table orders add column meter_debt      decimal (14,2) not null default 0;
alter table orders add column meter_cred      decimal (14,2) not null default 0;
\d orders
\q
\d product 
\d orders
logout
\q
\d product
\d coa_type 
select * from coa_type;
create type coa_types as enum('non-postable', 'postable', 'linked');
alter table coa drop column coa_type;
alter table coa drop column type_id;
\d coa;
alter table coa drop column coa_type_id;
alter table coa add column coa_type as coa_types not null default 'postable';
alter table coa add column coa_type coa_types not null default 'postable';
\d coa
select id, coa_type, name from coa;
alter table coa drop column coa_type;
drop enum coa_types;
drop enums coa_types;
drop type coa_types;
create type postable_type as enum('none', 'postable');
create type linked_type as enum('none', 'linked');
drop type linked_type ;
create type linkable_type as enum('none', 'linked');
alter table add column postable postable_type not null default 'postable';
alter table coa add column postable postable_type not null default 'postable';
alter table coa add column linkable linkable_type not null default 'none';
\d coa;
select id, name, postable, linkable from coa;
alter table coa drop column link;
\d coa;
\e
\d
\t
\d coa
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type 
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type 
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0;
select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c;
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type 
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type 
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type,
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
select id, name, code, linkable from get_coa_list(4::smallint);
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkabel_type, 
postable postable_type,
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.postable,
      p.linkable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkabel_type, 
postable postable_type,
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.postable,
      p.linkable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkabel_type, 
postable postable_type,
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.postable,
      p.linkable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
\d coa
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkable_type, 
postable postable_type,
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.postable,
      p.linkable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkable_type, 
postable postable_type,
link character varying(50)[]
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.linkable,
      p.postable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkable_type, 
postable postable_type
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.linkable,
      p.postable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
select id, name, postable, linkable from coa;
drop type linkable_type;
drop type linkable_type cascade;
select id, name, postable, linkable from coa;
select id, name, postable from coa;
\d coa
create type linkable_type as enum('none', 'linkable');
alter table coa add column linkable linkable_type not null default 'none';
select id, name, postable, linkable from coa;
select id, name, code from get_coa_list(4::smallint);
  
drop function get_coa_list;
create function get_coa_list(p_length smallint)
returns table (
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
postable postable_type,
linkable linkable_type, 
parent_id int, 
updated_at varchar(20),
cct character varying(4)
)
language plpgsql
as $$

begin

 return query with recursive coa_tree as (
 select p.id, p.code, p.name, p.tax_id, p.description, p.postable,
    p.linkable, p.parent_id, p.updated_at, RPAD(p.code::varchar(4), 4, '0') as cct
  from coa as p
  where p.parent_id = 0
  
  union all
  
  select c.id, c.code, c.name, c.tax_id, c.description, c.postable,
    c.linkable, c.parent_id, c.updated_at, RPAD(c.code::varchar(4), 4, '0') as cct
  from coa as c
  join coa_tree p on c.parent_id = p.id
  )
  select 
    t.id,
    t.code,
    t.name,
    t.tax_id,
    t.description,
    t.postable,
    t.linkable,
    t.parent_id,
    to_char(t.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
    t.cct::varchar(4)
 from coa_tree as t
 where length(t.code::varchar(4)) < p_length
 order by t.cct ;
 
end;
$$
;
select id, name, code from get_coa_list(4::smallint);
drop function search_coa;
    
create function search_coa(p_name varchar(50))
returns table (
parent_id int, 
id int, 
code int, 
name character varying(50), 
tax_id int, 
description character varying(256), 
updated_at varchar(20),
linkabel linkable_type, 
postable postable_type
)
language plpgsql
as $$

begin

 return query select
      p.parent_id,
      p.id,
      p.code,
      p.name,
      p.tax_id,
      p.description,
      to_char(p.updated_at, 'YYYY-MM-DD HH24:MM:MMI')::varchar(20) as updated_at,
      p.linkable,
      p.postable
    FROM coa AS p
    WHERE POSITION(p_name IN LOWER(p.name)) > 0;

 
end;
$$
;
select id, name, code from search_coa('utang'::varchar(50));
select id, code, name from get_coa_parent();
select id, code, name from coa;;
select id, code, name, postable from coa;;
select id, code, name, postable from coa;;
select id, code, name, postable, linkable from coa;;
select id, code, name, postable, linkable from coa;;
create table vac1 (
id varchar(50) not null primary key,
name varchar(50) not null,
birth_date timestamp not null,
first_date timestamp not null,
next_date timestamp not null,
vac_type varchar(25) not null,
first_batch varchar(25) not null,
next_batch varchar(25) not null,
first_qr varchar(25) not null,
next_qr varchar(25) not null);
\d vac1
alter table vac1 add column nik varchar(25) not null;
\d vac1
update users set name = 'Agung' where name = 'Agunf';
\q
create table vac1 (
id varchar(50) not null primary key,
name varchar(50) not null,
birth_date timestamp not null,
first_date timestamp not null,
next_date timestamp not null,
vac_type varchar(25) not null,
first_batch varchar(25) not null,
next_batch varchar(25) not null,
first_qr varchar(25) not null,
next_qr varchar(25) not null);
\d vac1
\q
\d sub_vac2
\d      vac2
\q
delete from vac2 ;
\q
\d products
\d product
alter table product alter column buy_price decimal(10,2);
alter table product alter column buy_price type decimal(10,2);
alter table product alter column sale_price type decimal(10,2);
\d product
alter table product alter column id type integer;
\q
\d product
alter table product alter column id type integer;
alter table product alter column buy_price type decimal(10,2);
alter table product alter column sale_price type decimal(10,2);
create table coa_link (
id smallint not null,
code varchar(3) not null,
acc_id integer not null
);
alter table coa_link add primary key(code, id);
CREATE INDEX uq_coa_link_name ON coa_link USING btree (acc_id);
alter table only coa_link add constraint fk_coa_link foreign key (acc_id) references coa(id) ON UPDATE CASCADE ON DELETE CASCADE;
alter table orders add column discount decimal(10,2) not null default 0;
\q
INSERT INTO public.product (id, name, unit, description, buy_price, sale_price, octan, created_at, updated_at, parent_id, spbu_id, barcode, be_sold, content, code, first_stock) VALUES (46, 'Jarum Super', 'dus', NULL, 2500000.00, 3000000.00, 0.00, '2021-09-23 08:41:45.076319', '2021-09-23 08:41:45.076319', 0, 1, '12345', true, 200, 100, 0.00);
INSERT INTO public.product (id, name, unit, description, buy_price, sale_price, octan, created_at, updated_at, parent_id, spbu_id, barcode, be_sold, content, code, first_stock) VALUES (50, 'Jarum Super (bos)', 'bos', NULL, 260000.00, 305000.00, 0.00, '2021-09-23 08:45:29.133668', '2021-09-23 08:45:29.133668', 46, 1, '123456', true, 20, 1001, 0.00);
INSERT INTO public.product (id, name, unit, description, buy_price, sale_price, octan, created_at, updated_at, parent_id, spbu_id, barcode, be_sold, content, code, first_stock) VALUES (51, 'Jarum Super (slop)', 'slop', NULL, 110000.00, 120000.00, 0.00, '2021-09-23 08:47:05.141717', '2021-09-23 08:47:05.141717', 46, 1, '1234567', true, 10, 1002, 0.00);
INSERT INTO public.product (id, name, unit, description, buy_price, sale_price, octan, created_at, updated_at, parent_id, spbu_id, barcode, be_sold, content, code, first_stock) VALUES (52, 'Jarum Super (bks)', 'bks', NULL, 20000.00, 23000.00, 0.00, '2021-09-23 08:48:30.355993', '2021-09-23 08:48:30.355993', 46, 1, '123', true, 1, 1003, 0.00);
\d product 
\q
\d users;
select * from users;
select id, name, password from users;
select id, name, email, password from users;
select id, journal_id from journal_detail ;
select id, journal_id, debt, cred from journal_detail ;
select id, journal_id, debt, cred from journal_detail ;
select id, journal_id, debt, cred from journal_detail ;
select id, journal_id, debt, cred from journal_detail where id=47;
select id, journal_id, debt, cred from journal_detail where id=47;
select id, journal_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
delete from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
delete from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
select id, journal_id, coa_id, debt, cred from journal_detail where journal_id=47;
\q
select id, nama, photo from users;
select id, name, photo from users;
\q
\d journal
SELECT
      p.id,
      p.user_id,
      p.code,
      p.ref_id,
      p.code||'-'||to_char(p.id,'000000000') as proof,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateOutput",
      p.date_transact,
      p.tags,
      p.memo,
      p.created_at,
      p.updated_at,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as operator,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as supplier
    FROM journal AS p
    WHERE p.code = 'ORD'
    AND (
      p.date_transact >= to_timestamp($1, $2)
      AND p.date_transact <= to_timestamp($3, $4)
    );
SELECT
      p.id,
      p.user_id,
      p.code,
      p.ref_id,
      p.code||'-'||to_char(p.id,'000000000') as proof,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateOutput",
      p.date_transact,
      p.tags,
      p.memo,
      p.created_at,
      p.updated_at,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as operator,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as supplier
    FROM journal AS p
    WHERE p.code = 'ORD';
SELECT
      p.id, p.code, p.ref_id, p.proof, p.user_id,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateTransact",
      p.tags, p.memo,
      s.created_at AS "createdAt", s.updated_at AS "updatedAt",
    coalesce(
      (
        SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id AS "journalId", s.coa_id AS "coaId",
      s.description, s.debt, s.cred, s.saldo,
      s.created_at AS "createdAt", s.updated_at AS "updatedAt"
    FROM journal_detail AS s
    WHERE s.journal_id = p.id) x
      ),
      '[]'
    )
   as "details",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as operator,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as operator
    FROM journal AS p
    WHERE p.id = 47
;
\d journal_detail
SELECT
      p.id, p.code, p.ref_id, p.proof, p.user_id,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateTransact",
      p.tags, p.memo,
      s.created_at AS "createdAt", s.updated_at AS "updatedAt",
    coalesce(
      (
        SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id AS "journalId", s.coa_id AS "coaId",
      s.description, s.debt, s.cred,
      s.created_at AS "createdAt", s.updated_at AS "updatedAt"
    FROM journal_detail AS s
    WHERE s.journal_id = p.id) x
      ),
      '[]'
    )
   as "details",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as operator,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as operator
    FROM journal AS p
    WHERE p.id = 47;
SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.description, s.debt, s.cred,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = 47;
SELECT
      p.id, p.code, p.ref_id, p.proof, p.user_id,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateTransact",
      p.tags, p.memo,
      s.created_at AS "createdAt", s.updated_at AS "updatedAt",
    coalesce(
      (
        SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.description, s.debt, s.cred,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = p.id) x
      ),
      '[]'
    )
   as "details",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as operator,
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as operator
    FROM journal AS p
    WHERE p.id = 47;
 SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.debt, s.cred, s.description,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = p.id) x
      );
 SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.debt, s.cred, s.description,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = p.id) x
      ;
 SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.debt, s.cred, s.description,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = 47) x
      ;
SELECT
      p.id, p.code, p.ref_id, p.proof, p.user_id,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateTransact",
      p.tags, p.memo,
      p.created_at AS "createdAt", p.updated_at AS "updatedAt",
    coalesce(
      (
        SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.debt, s.cred, s.description,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = p.id) x
      ),
      '[]'
    )
   as "details",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as "operator",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as "supplier"
    FROM journal AS p
    WHERE p.id = 47;
SELECT
      p.id, p.code, p.ref_id, p.proof, p.user_id,
      to_char(p.date_transact, 'DD-MON-YYYY') AS "dateOutput",
      p.date_transact, p.tags, p.memo,
      p.created_at AS "createdAt", p.updated_at AS "updatedAt",
    coalesce(
      (
        SELECT array_to_json(array_agg(row_to_json(x)))
        FROM (SELECT
      s.id, s.journal_id "journalId", s.coa_id "coaId",
      s.debt, s.cred, s.description,
      s.created_at "createdAt", s.updated_at "updatedAt"
    FROM journal_detail s
    WHERE s.journal_id = p.id) x
      ),
      '[]'
    )
   as "details",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.user_id
    ) x)
   as "operator",
    (SELECT row_to_json(x) FROM (select
    t.id, t.name, t.email, t.street, t.city, t.phone, t.spbu_id
    from users as t
    where t.id = p.customer_id
    ) x)
   as "supplier"
    FROM journal AS p
    WHERE p.id = 0;
\q
\d
\d spbu
\d users;
\d
\d coa_type 
select * from coa_type ;
insert into coa_type (name) values ('Linked') on conflict(name) do nothing;
\d coa_type 
create unique index uq_coa_type_name on coa_type(name);
insert into coa_type (name) values ('Linked') on conflict(name) do nothing;
select * from coa_type ;
insert into coa_type (name) values ('Postable') on conflict(name) do nothing returning *;
insert into coa_type (name) values ('Test') on conflict(name) do nothing returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('Test', 'Welcome') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('Test', 'Welcome to the jungle') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('test', 'Welcome to the jungle') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('test', 'Welcome to the jungle 2') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('Linked', 'Welcome to the jungle 2') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
insert into coa_type (name, description) values ('Tester', 'Welcome to the jungle 2') on conflict(name) do update set description = Excluded.description returning *;
select * from coa_type ;
ls -l
;
\d
\q
create database downy
;
CREATE SEQUENCE public.seq_user
    AS smallint
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
create type roles as enum ('Owner', 'Admin', 'Customer', 'User');
CREATE TABLE public.users (
    id integer DEFAULT nextval('public.seq_user'::regclass) NOT NULL,
    name character varying(50) NOT NULL,
    email character varying(128) NOT NULL,
    password character varying(128) NOT NULL,
    role roles not null default 'User',
);
CREATE TABLE public.users (
    id integer DEFAULT nextval('public.seq_user'::regclass) NOT NULL,
    name character varying(50) NOT NULL,
    email character varying(128) NOT NULL,
    password character varying(128) NOT NULL,
    role roles not null default 'User'
);
\d users;
\e
CREATE TABLE public.users (
    id integer DEFAULT nextval('public.seq_user'::regclass) NOT NULL,
    name character varying(50) NOT NULL,
    email character varying(128) NOT NULL,
    password character varying(128) NOT NULL,
    role roles not null default 'User'
);
\d
\s users;
